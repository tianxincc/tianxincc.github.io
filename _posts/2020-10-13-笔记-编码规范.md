---
layout: post
title: "编码规范"
date: 2020-10-13
tag: 笔记
---   

# 一本没看完书

# 编码规范
## 命名
1.不能以下划线或美元符号开始，也不能以下划线或美元符号结束
2.严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式
3.类名使用UpperCamelCase风格，方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格;必须遵从驼峰形式
5.常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长（MAX_STOCK_COUNT MAX_COUNT）
6.抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾
7.包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词
8.枚举类名建议带上Enum后缀，枚举成员名称需要全大写

### Service/DAO层方法命名规约
* 获取单个对象的方法用get做前缀。
* 获取多个对象的方法用list做前缀。
* 获取统计值的方法用count做前缀。
* 插入的方法用save（推荐）或insert做前缀。
* 删除的方法用remove（推荐）或delete做前缀。
* 修改的方法用update做前缀


## 常量定义
1.long或者Long初始赋值时，必须使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解
2.不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts下；系统配置相关的常量放在类：ConfigConsts下。
## 格式规约
1.大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：
* 左大括号前不换行。
* 左大括号后换行。
* 右大括号前换行。
* 右大括号后还有else等代码则不换行；表示终止右大括号后必须换行。
> public static void main(String args[]) {
	//缩进4个空格
	String say = "hello";
	//运算符的左右必须有一个空格
	int flag = 0;
	//关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格
	if (flag == 0) {
		System.out.println(say);
	}
	//左大括号前加空格且不换行；左大括号后换行
	if (flag == 1) {
		System.out.println("world");
		//右大括号前换行，右大括号后有else，不用换行
	} else {
		System.out.println("ok");
		//在右大括号后直接结束，则必须换行
	}
}

2.单行字符数限制不超过 120个，超出需要换行，换行时遵循如下原则：
* 第二行相对第一行缩进 4个空格，从第三行开始，不再继续缩进，参考示例。
* 运算符与下文一起换行。
* 方法调用的点符号与下文一起换行。
* 在多个参数超长，逗号后进行换行。
* 在括号前不要换行，见反例。
> 正例：
StringBuffer sb = new StringBuffer();
//超过120个字符的情况下，换行缩进4个空格，并且方法前的点符号一起换行
sb.append("zi").append("xin")...
	.append("huang")...
	.append("huang")...
	.append("huang");
反例：
StringBuffer sb = new StringBuffer();
//超过120个字符的情况下，不要在括号前换行
sb.append("zi").append("xin")...append
	("huang");
//参数很多的方法调用可能超过120个字符，不要在逗号前换行
method(args1, args2, args3, ...
	, argsX);

--- 

3.方法参数在定义和传入时，多个参数逗号后边必须加空格。
> 正例：下例中实参的"a",后边必须要有一个空格。
method("a", "b", "c");

4.没有必要增加若干空格来使某一行的字符与上一行的相应字符对齐。

## OOP规约
1.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。
2.当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。
3.在getter/setter方法中，尽量不要增加业务逻辑，增加排查问题的难度。
>反例：
public Integer getData(){
	if(true)  {
		return data + 100;
	} else {
		return data - 100;
	}
}

4.类成员与方法访问控制从严：
> 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。
工具类不允许有public或default构造方法。
类非static成员变量并且与子类共享，必须是protected。
类非static成员变量并且仅在本类使用，必须是private。
类static成员变量如果仅在本类使用，必须是private。
若是static成员变量，必须考虑是否为final。
类成员方法只供类内部调用，必须是private。
类成员方法只对继承类公开，那么限制为protected。
说明：任何类、方法、参数、变量，严控访问范围。过宽泛的访问范围，不利于模块解耦。

## 注释规约
1.类、类属性、类方法的注释必须使用Javadoc规范，使用/*内容/格式，不得使用//xxx方式。
>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。
2.所有的类都必须添加创建者信息。
3.方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/ */注释，注意与代码对齐。
4.所有的枚举类型字段必须要有注释，说明每个数据项的用途。
5.代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。

6.注释掉的代码尽量要配合说明，而不是简单的注释掉。
>说明：代码被注释掉有两种可能性:
后续会恢复此段代码逻辑。
永久不用。
前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。
## 控制语句
1.在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使它什么代码也没有。
2.在if/else/for/while/do语句中必须使用大括号，即使只有一行代码，避免使用下面的形式：if (condition) statements;
3.推荐尽量少用else， if-else的方式可以改写成：
>if(condition){
	...
	return obj;
}
//接着写else的业务逻辑代码;
说明：如果非得使用if()...else if()...else...方式表达逻辑，【强制】请勿超过 3层，
超过请使用状态设计模式。
正例：逻辑上超过 3层的if-else代码可以使用卫语句，或者状态模式来实现。

4.除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。
>正例：
//伪代码如下
boolean existed = (file.open(fileName, "w") != null) && (...) || (...);
if (existed) {
...
}
反例：
if ((file.open(fileName, "w") != null) && (...) || (...)) {
...
}

## 异常处理
1.异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。
2.对大段代码进行try-catch，这是不负责任的表现。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。
3.捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。
4.有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。
5.finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。
6.不能在finally块中使用return，finally块中的return返回后方法结束执行，不会再执行try块中的return语句。
7.方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。
## 日志处理
1.日志文件推荐至少保存15天，因为有些异常具备以“周”为频次发生的特点。
2.命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有stats/desc/monitor/visit等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。
>说明：推荐对日志进行分类，错误日志和业务日志尽量分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。
3.对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。
>说明：logger.debug("Processing trade with id: " + id + " symbol: " + symbol);如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。
正例：（占位符）
logger.debug("Processing trade with id: {} symbol : {} ", id, symbol);

4.避免重复打印日志，浪费磁盘空间
5.可以使用warn日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出error级别。
6.谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。
>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请

## 建表规约
1.表达是与否概念的字段，必须使用is_xxx的方式命名，数据类型是unsignedtinyint（ 1表示是，0表示否）
2.表名、字段名必须使用小写字母或数字；禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。
3.禁用保留字，如desc、range、match、delayed等
4.小数类型为decimal，禁止使用float和double。
>说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。
5.varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。
6.表必备三字段：id, gmt_create, gmt_modified。
7.库名与应用名称尽量一致。
8.如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。
9.不要使用count(列名)或count(常量)来替代count()，count()就是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。
>说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。
10.当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。









